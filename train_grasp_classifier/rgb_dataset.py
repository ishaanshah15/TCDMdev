from __future__ import print_function

import imageio
import numpy as np
import os
import xml.etree.ElementTree as ET

import torch
import torch.nn
from PIL import Image
import torchvision.transforms as transforms
from torch.utils.data import Dataset


class Dataset2D(Dataset):
   

    def __init__(self, paths,use_params=False):
        super().__init__()
        print('new')
        self.img_paths = [p[1] for p in paths]
        self.labels = [int(p[0]) for p in paths]
        self.use_params = use_params

        if use_params:
            self.param_files = [p[2] for p in paths]

        self.tasks = [t[-1] for t in paths]
        self.test1 = [t[-3] for t in paths]
        self.test2 = [t[-2] for t in paths]
        self.size = 64
        

    def __len__(self):
        return len(self.img_paths)    

    def get_random_augmentations(self):
        # TODO return a list of random data augmentation transforms here
        # NOTE - make sure to not augment during test and replace random crops with center crops 
        # Hint: There are lots of possible data augmentations
        # Some commonly used ones are random crops, flipping, rotation
        # You are encouraged to read the docs https://pytorch.org/vision/stable/transforms.html
        # Depending on the augmentation you use, your final image size will change and you will have to write the correct value of `flat_dim` in line 46 in simple_cnn.py
        transform_list = []
        
        
        if False:
            pass
            #transform_list.append(transforms.RandomVerticalFlip([0.5]))
            #transform_list.append(transforms.RandomHorizontalFlip([0.5]))
            #transform_list.append(transforms.RandomRotation((-45,45)))
            transform_list.append(transforms.RandomResizedCrop(self.size))
            #transform_list.append(transforms.RandomHorizontalFlip())
            transform_list.append(transforms.GaussianBlur(kernel_size=5))
        
        return transform_list
        

    def get_connections(self,params):
        points = []
        points.append(params[6] - params[3])
        points.append(params[12] - params[6])
        points.append(params[9] - params[12])
        points.append(params[3] - params[15])
        points = np.concatenate(points)
        params = params.reshape((48,))
        params = np.concatenate([params,points])
        return params



    def __getitem__(self, index):
        """
        :param index: a int generated by Dataloader in range [0, __len__()]
        :return: index-th element
        image: FloatTensor in shape of (C, H, W) in scale [-1, 1].
        label: LongTensor in shape of (Nc, ) binary label
        weight: FloatTensor in shape of (Nc, ) difficult or not.
        """

        




        fpath = self.img_paths[index]
        img = Image.open(fpath)

        half_img = np.array(img)[:,256:]
        img = Image.fromarray(half_img)

        
        """
        of_im = self.img_paths[index].split('/')[-3]
        of_path = '/home/ishaans/grasp_outputs/object_frames_back'
        of_path = os.path.join(of_path,of_im + '.png')
        img = Image.open(of_path)
        
        
        img.save('test_ex.png')
        """

        
        
        
        trans = transforms.Compose([
            transforms.Resize((self.size,self.size)),
            *self.get_random_augmentations(),
            transforms.ToTensor(),
            transforms.Normalize(mean=[0.485, 0.457, 0.407], std=[0.5, 0.5, 0.5]),
        ])

        img = trans(img)
        label = self.labels[index] 
        image = torch.FloatTensor(img)
        


    
        if not self.use_params:
            return {'images':image,'params': 0, 'labels':label, 'paths':fpath, 
                    'test1':int(self.test1[index]),'test2':int(self.test2[index]),
                    'task':self.tasks[index]}


        params = np.load(self.param_files[index])
        params = params.reshape((48,))
        #params = params - np.mean(params,axis=0)

        #params = self.get_connections(params)
        
        
        return {'images':image,'params': params, 'labels':label, 'paths':fpath,
                'test1':int(self.test1[index]),'test2':int(self.test2[index]),
                'task':self.tasks[index]}

    

if __name__ == '__main__':
    from prepare_data import get_dataset2d
    train_set,test_set = get_dataset2d()
    import ipdb
    ipdb.set_trace()
